//
// Generated file, do not edit! Created by nedtool 5.6 from FeudalMsg.msg.
//

#ifndef __FEUDALMSG_M_H
#define __FEUDALMSG_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include "artery/application/platooning/FeudalisticPlatooningDefinitions.h"
// }}

/**
 * Class generated from FeudalMsg.msg by nedtool.
 * <pre>
 * packet SimpleArrayMsg
 * {
 *     uint8_t data[];
 * }
 * </pre>
 */
class SimpleArrayMsg : public ::omnetpp::cPacket
{
  protected:
    uint8_t *data; // array ptr
    unsigned int data_arraysize;

  private:
    void copy(const SimpleArrayMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SimpleArrayMsg&);

  public:
    SimpleArrayMsg(const char *name=nullptr, short kind=0);
    SimpleArrayMsg(const SimpleArrayMsg& other);
    virtual ~SimpleArrayMsg();
    SimpleArrayMsg& operator=(const SimpleArrayMsg& other);
    virtual SimpleArrayMsg *dup() const override {return new SimpleArrayMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setDataArraySize(unsigned int size);
    virtual unsigned int getDataArraySize() const;
    virtual uint8_t getData(unsigned int k) const;
    virtual void setData(unsigned int k, uint8_t data);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SimpleArrayMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SimpleArrayMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/tobiasrenzler/software/artery_2020_04/artery/src/artery/application/platooning/FeudalMsg.msg:18</tt> by nedtool.
 * <pre>
 * packet VassalMsg
 * {
 *     uint32_t vassalageID;
 *     SimpleArrayMsg cams[];
 *     SimpleArrayMsg denms[];
 * }
 * </pre>
 */
class VassalMsg : public ::omnetpp::cPacket
{
  protected:
    uint32_t vassalageID;
    SimpleArrayMsg *cams; // array ptr
    unsigned int cams_arraysize;
    SimpleArrayMsg *denms; // array ptr
    unsigned int denms_arraysize;

  private:
    void copy(const VassalMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VassalMsg&);

  public:
    VassalMsg(const char *name=nullptr, short kind=0);
    VassalMsg(const VassalMsg& other);
    virtual ~VassalMsg();
    VassalMsg& operator=(const VassalMsg& other);
    virtual VassalMsg *dup() const override {return new VassalMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getVassalageID() const;
    virtual void setVassalageID(uint32_t vassalageID);
    virtual void setCamsArraySize(unsigned int size);
    virtual unsigned int getCamsArraySize() const;
    virtual SimpleArrayMsg& getCams(unsigned int k);
    virtual const SimpleArrayMsg& getCams(unsigned int k) const {return const_cast<VassalMsg*>(this)->getCams(k);}
    virtual void setCams(unsigned int k, const SimpleArrayMsg& cams);
    virtual void setDenmsArraySize(unsigned int size);
    virtual unsigned int getDenmsArraySize() const;
    virtual SimpleArrayMsg& getDenms(unsigned int k);
    virtual const SimpleArrayMsg& getDenms(unsigned int k) const {return const_cast<VassalMsg*>(this)->getDenms(k);}
    virtual void setDenms(unsigned int k, const SimpleArrayMsg& denms);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const VassalMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, VassalMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/tobiasrenzler/software/artery_2020_04/artery/src/artery/application/platooning/FeudalMsg.msg:25</tt> by nedtool.
 * <pre>
 * packet FeudalSync
 * {
 *     uint16_t ref;
 *     uint32_t members[];
 *     uint32_t lteAddresses[];
 * }
 * </pre>
 */
class FeudalSync : public ::omnetpp::cPacket
{
  protected:
    uint16_t ref;
    uint32_t *members; // array ptr
    unsigned int members_arraysize;
    uint32_t *lteAddresses; // array ptr
    unsigned int lteAddresses_arraysize;

  private:
    void copy(const FeudalSync& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FeudalSync&);

  public:
    FeudalSync(const char *name=nullptr, short kind=0);
    FeudalSync(const FeudalSync& other);
    virtual ~FeudalSync();
    FeudalSync& operator=(const FeudalSync& other);
    virtual FeudalSync *dup() const override {return new FeudalSync(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getRef() const;
    virtual void setRef(uint16_t ref);
    virtual void setMembersArraySize(unsigned int size);
    virtual unsigned int getMembersArraySize() const;
    virtual uint32_t getMembers(unsigned int k) const;
    virtual void setMembers(unsigned int k, uint32_t members);
    virtual void setLteAddressesArraySize(unsigned int size);
    virtual unsigned int getLteAddressesArraySize() const;
    virtual uint32_t getLteAddresses(unsigned int k) const;
    virtual void setLteAddresses(unsigned int k, uint32_t lteAddresses);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FeudalSync& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FeudalSync& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/tobiasrenzler/software/artery_2020_04/artery/src/artery/application/platooning/FeudalMsg.msg:32</tt> by nedtool.
 * <pre>
 * packet FeudalMsg
 * {
 *     uint8_t msgType \@enum(MessageTypeFeudalisticPlatoon);
 *     uint32_t txStationID;
 *     simtime_t timestamp;
 *     uint32_t platoonID;
 *     uint32_t vassalageID;
 *     FeudalSync syncMsg[];
 *     VassalMsg vassalMsg[];
 * }
 * </pre>
 */
class FeudalMsg : public ::omnetpp::cPacket
{
  protected:
    uint8_t msgType;
    uint32_t txStationID;
    ::omnetpp::simtime_t timestamp;
    uint32_t platoonID;
    uint32_t vassalageID;
    FeudalSync *syncMsg; // array ptr
    unsigned int syncMsg_arraysize;
    VassalMsg *vassalMsg; // array ptr
    unsigned int vassalMsg_arraysize;

  private:
    void copy(const FeudalMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FeudalMsg&);

  public:
    FeudalMsg(const char *name=nullptr, short kind=0);
    FeudalMsg(const FeudalMsg& other);
    virtual ~FeudalMsg();
    FeudalMsg& operator=(const FeudalMsg& other);
    virtual FeudalMsg *dup() const override {return new FeudalMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getMsgType() const;
    virtual void setMsgType(uint8_t msgType);
    virtual uint32_t getTxStationID() const;
    virtual void setTxStationID(uint32_t txStationID);
    virtual ::omnetpp::simtime_t getTimestamp() const;
    virtual void setTimestamp(::omnetpp::simtime_t timestamp);
    virtual uint32_t getPlatoonID() const;
    virtual void setPlatoonID(uint32_t platoonID);
    virtual uint32_t getVassalageID() const;
    virtual void setVassalageID(uint32_t vassalageID);
    virtual void setSyncMsgArraySize(unsigned int size);
    virtual unsigned int getSyncMsgArraySize() const;
    virtual FeudalSync& getSyncMsg(unsigned int k);
    virtual const FeudalSync& getSyncMsg(unsigned int k) const {return const_cast<FeudalMsg*>(this)->getSyncMsg(k);}
    virtual void setSyncMsg(unsigned int k, const FeudalSync& syncMsg);
    virtual void setVassalMsgArraySize(unsigned int size);
    virtual unsigned int getVassalMsgArraySize() const;
    virtual VassalMsg& getVassalMsg(unsigned int k);
    virtual const VassalMsg& getVassalMsg(unsigned int k) const {return const_cast<FeudalMsg*>(this)->getVassalMsg(k);}
    virtual void setVassalMsg(unsigned int k, const VassalMsg& vassalMsg);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FeudalMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FeudalMsg& obj) {obj.parsimUnpack(b);}


#endif // ifndef __FEUDALMSG_M_H

